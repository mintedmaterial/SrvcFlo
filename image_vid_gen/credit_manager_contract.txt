// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * @title CreditManager
 * @dev Manages AI generation credits for ServiceFlow AI on Sonic blockchain
 * Supports payments in S (native), wS (wrapped S), and USDC
 * Includes 20% bonus for crypto payments and FeeM integration
 */
contract CreditManager is Ownable, ReentrancyGuard, Pausable {
    
    // Events
    event CreditsPurchased(
        address indexed user,
        uint256 amount,
        uint256 credits,
        string paymentMethod,
        uint256 timestamp
    );
    
    event CreditsBurned(
        address indexed user,
        uint256 credits,
        string taskId,
        uint256 timestamp
    );
    
    event FeeMRegistered(address indexed contract_address);
    
    // State variables
    mapping(address => uint256) public credits;
    mapping(string => bool) public usedTaskIds; // Prevent duplicate burns
    
    IERC20 public immutable usdc;
    IERC20 public immutable ws; // Wrapped S
    AggregatorV3Interface public immutable priceFeed; // S/USD price feed
    
    // FeeM registrar address on Sonic
    address public constant FEEM_REGISTRAR = 0xDC2B0D2Dd2b7759D97D50db4eabDC36973110830;
    
    // Credit rates (credits per USD)
    uint256 public constant FIAT_RATE = 150; // 150 credits per USD for fiat
    uint256 public constant CRYPTO_RATE = 180; // 180 credits per USD for crypto (20% bonus)
    
    // Minimum purchase amounts (in USD with 8 decimals)
    uint256 public constant MIN_PURCHASE_USD = 100000000; // $1.00
    
    // Price feed decimals (usually 8 for Chainlink)
    uint8 public constant PRICE_DECIMALS = 8;
    
    constructor(
        address _usdc,
        address _ws,
        address _priceFeed
    ) {
        require(_usdc != address(0), "Invalid USDC address");
        require(_ws != address(0), "Invalid wS address");
        require(_priceFeed != address(0), "Invalid price feed address");
        
        usdc = IERC20(_usdc);
        ws = IERC20(_ws);
        priceFeed = AggregatorV3Interface(_priceFeed);
    }
    
    /**
     * @dev Register with FeeM to receive fee rewards
     * Can only be called by owner
     */
    function registerMe() external onlyOwner {
        (bool success,) = FEEM_REGISTRAR.call("");
        require(success, "FeeM registration failed");
        emit FeeMRegistered(address(this));
    }
    
    /**
     * @dev Buy credits with native S tokens
     * Includes 20% bonus for crypto payment
     */
    function buyCreditsWithS() external payable nonReentrant whenNotPaused {
        require(msg.value > 0, "Must send S tokens");
        
        uint256 usdValue = _getSValueInUSD(msg.value);
        require(usdValue >= MIN_PURCHASE_USD, "Purchase amount too small");
        
        uint256 creditsToAdd = (usdValue * CRYPTO_RATE) / (10 ** PRICE_DECIMALS);
        credits[msg.sender] += creditsToAdd;
        
        emit CreditsPurchased(
            msg.sender,
            msg.value,
            creditsToAdd,
            "S",
            block.timestamp
        );
    }
    
    /**
     * @dev Buy credits with wrapped S tokens
     * Includes 20% bonus for crypto payment
     */
    function buyCreditsWithWS(uint256 amount) external nonReentrant whenNotPaused {
        require(amount > 0, "Amount must be greater than 0");
        
        uint256 usdValue = _getSValueInUSD(amount);
        require(usdValue >= MIN_PURCHASE_USD, "Purchase amount too small");
        
        // Transfer wS tokens from user
        ws.transferFrom(msg.sender, address(this), amount);
        
        uint256 creditsToAdd = (usdValue * CRYPTO_RATE) / (10 ** PRICE_DECIMALS);
        credits[msg.sender] += creditsToAdd;
        
        emit CreditsPurchased(
            msg.sender,
            amount,
            creditsToAdd,
            "wS",
            block.timestamp
        );
    }
    
    /**
     * @dev Buy credits with USDC
     * Standard rate without crypto bonus
     */
    function buyCreditsWithUSDC(uint256 amount) external nonReentrant whenNotPaused {
        require(amount > 0, "Amount must be greater than 0");
        
        // USDC typically has 6 decimals
        uint256 usdValue = amount * (10 ** (PRICE_DECIMALS - 6)); // Convert to 8 decimals
        require(usdValue >= MIN_PURCHASE_USD, "Purchase amount too small");
        
        // Transfer USDC tokens from user
        usdc.transferFrom(msg.sender, address(this), amount);
        
        uint256 creditsToAdd = (usdValue * FIAT_RATE) / (10 ** PRICE_DECIMALS);
        credits[msg.sender] += creditsToAdd;
        
        emit CreditsPurchased(
            msg.sender,
            amount,
            creditsToAdd,
            "USDC",
            block.timestamp
        );
    }
    
    /**
     * @dev Burn credits for AI generation
     * Can only be called by owner (backend service)
     */
    function burnCredits(
        address user,
        uint256 amount,
        string calldata taskId
    ) external onlyOwner nonReentrant {
        require(user != address(0), "Invalid user address");
        require(amount > 0, "Amount