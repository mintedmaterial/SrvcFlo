#!/usr/bin/env python3
"""
Auditooor Cloud Agent - ServiceFlow AI
Simplified version for Railway deployment with smart contract auditing and generation
"""

import os
import json
import asyncio
from typing import Dict, Any, Optional, List
from datetime import datetime

# Import our cloud tools
from Tools.chaingpt_audit_tool import audit_contract_with_chaingpt, analyze_contract_security
from cloudflare_rag_cloud import search_serviceflow_docs_rag, search_contracts_rag

class AuditooorCloud:
    """Cloud-optimized Auditooor agent for Railway deployment"""

    def __init__(self):
        self.service_name = "Auditooor Cloud Agent"
        self.version = "1.0.0"

    # OpenZeppelin contract generation templates
    def generate_erc20_template(self, requirements: Dict[str, Any]) -> Dict[str, Any]:
        """Generate ERC-20 token contract template using OpenZeppelin MCP API"""
        try:
            import requests

            name = requirements.get("name", "MyToken")
            symbol = requirements.get("symbol", "MTK")
            premint = requirements.get("premint", "1000000")

            # Try OpenZeppelin MCP API first
            try:
                ozeppelin_api = "https://mcp.openzeppelin.com/contracts/solidity/mcp"
                contract_params = {
                    "name": name,
                    "symbol": symbol,
                    "premint": premint,
                    "mintable": requirements.get('mintable', True),
                    "burnable": requirements.get('burnable', False),
                    "pausable": requirements.get('pausable', False),
                    "permit": requirements.get('permit', False),
                    "votes": requirements.get('votes', False),
                    "access": requirements.get('access', 'ownable'),
                    "upgradeable": requirements.get('upgradeable', False)
                }

                response = requests.post(
                    f"{ozeppelin_api}/erc20",
                    json=contract_params,
                    timeout=30
                )

                if response.status_code == 200:
                    oz_result = response.json()
                    contract_code = oz_result.get('contract_code', '')
                    if contract_code:
                        return {
                            "success": True,
                            "contract_code": contract_code,
                            "contract_type": "ERC20",
                            "name": name,
                            "symbol": symbol,
                            "source": "OpenZeppelin MCP API",
                            "features": list(contract_params.keys())
                        }

            except requests.exceptions.RequestException as e:
                print(f"OpenZeppelin API failed, using fallback: {e}")

            # Fallback to internal template
            mintable = requirements.get("mintable", True)
            burnable = requirements.get("burnable", False)
            pausable = requirements.get("pausable", False)

            # Basic ERC-20 template with OpenZeppelin security patterns
            contract_code = f"""// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";"""

            if pausable:
                contract_code += """
import "@openzeppelin/contracts/security/Pausable.sol";"""

            if burnable:
                contract_code += """
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";"""

            contract_code += f"""

/**
 * @title {name}
 * @dev ERC-20 token generated by Auditooor - ServiceFlow AI
 * Generated on: {datetime.now().isoformat()}
 *
 * Security features:
 * - OpenZeppelin standard implementation
 * - Access control with Ownable pattern
 * - Reentrancy protection
 * {('- Pausable functionality' if pausable else '')}
 * {('- Burnable tokens' if burnable else '')}
 * {('- Mintable by owner' if mintable else '')}
 */
contract {name} is ERC20, Ownable, ReentrancyGuard{(', Pausable' if pausable else '')}{(', ERC20Burnable' if burnable else '')} {{

    /**
     * @dev Constructor that sets up the token with initial parameters
     * @param initialOwner Address that will own the contract
     */
    constructor(address initialOwner)
        ERC20("{name}", "{symbol}")
        Ownable(initialOwner)
    {{
        // Mint initial supply to the deployer
        _mint(msg.sender, {premint} * 10 ** decimals());

        // Transfer ownership to specified address if different
        if (initialOwner != msg.sender) {{
            _transferOwnership(initialOwner);
        }}
    }}"""

            if mintable:
                contract_code += f"""

    /**
     * @dev Mint tokens to specified address
     * @param to Address to receive the tokens
     * @param amount Amount of tokens to mint (in wei)
     */
    function mint(address to, uint256 amount)
        public
        onlyOwner
        nonReentrant
        {('whenNotPaused' if pausable else '')}
    {{
        require(to != address(0), "{name}: mint to zero address");
        require(amount > 0, "{name}: mint amount must be positive");
        _mint(to, amount);
    }}"""

            if pausable:
                contract_code += f"""

    /**
     * @dev Pause all token transfers
     */
    function pause() public onlyOwner {{
        _pause();
    }}

    /**
     * @dev Unpause all token transfers
     */
    function unpause() public onlyOwner {{
        _unpause();
    }}

    /**
     * @dev Override transfer functions to include pause functionality
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override whenNotPaused {{
        super._beforeTokenTransfer(from, to, amount);
    }}"""

            contract_code += """

    /**
     * @dev Emergency function to recover accidentally sent tokens
     * @param tokenAddress Address of the token contract
     * @param tokenAmount Amount of tokens to recover
     */
    function recoverERC20(address tokenAddress, uint256 tokenAmount)
        public
        onlyOwner
        nonReentrant
    {
        require(tokenAddress != address(this), "Cannot recover own token");
        IERC20(tokenAddress).transfer(owner(), tokenAmount);
    }
}"""

            return {
                "contract_code": contract_code,
                "contract_name": name,
                "contract_type": "ERC-20",
                "features": {
                    "mintable": mintable,
                    "burnable": burnable,
                    "pausable": pausable,
                    "premint": premint
                },
                "status": "success",
                "timestamp": datetime.now().isoformat()
            }

        except Exception as e:
            return {
                "error": f"ERC-20 generation failed: {str(e)}",
                "status": "error"
            }

    def generate_erc721_template(self, requirements: Dict[str, Any]) -> Dict[str, Any]:
        """Generate ERC-721 NFT contract template using OpenZeppelin MCP API"""
        try:
            import requests

            name = requirements.get("name", "MyNFT")
            symbol = requirements.get("symbol", "MNFT")
            base_uri = requirements.get("baseUri", "https://api.example.com/metadata/")

            # Try OpenZeppelin MCP API first
            try:
                ozeppelin_api = "https://mcp.openzeppelin.com/contracts/solidity/mcp"
                contract_params = {
                    "name": name,
                    "symbol": symbol,
                    "baseUri": base_uri,
                    "mintable": requirements.get('mintable', True),
                    "burnable": requirements.get('burnable', False),
                    "pausable": requirements.get('pausable', False),
                    "enumerable": requirements.get('enumerable', False),
                    "uriStorage": requirements.get('uriStorage', False),
                    "access": requirements.get('access', 'ownable'),
                    "upgradeable": requirements.get('upgradeable', False)
                }

                response = requests.post(
                    f"{ozeppelin_api}/erc721",
                    json=contract_params,
                    timeout=30
                )

                if response.status_code == 200:
                    oz_result = response.json()
                    contract_code = oz_result.get('contract_code', '')
                    if contract_code:
                        return {
                            "success": True,
                            "contract_code": contract_code,
                            "contract_type": "ERC721",
                            "name": name,
                            "symbol": symbol,
                            "source": "OpenZeppelin MCP API",
                            "features": list(contract_params.keys())
                        }

            except requests.exceptions.RequestException as e:
                print(f"OpenZeppelin API failed, using fallback: {e}")

            # Fallback to internal template

            contract_code = f"""// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title {name}
 * @dev ERC-721 NFT contract generated by Auditooor - ServiceFlow AI
 * Generated on: {datetime.now().isoformat()}
 */
contract {name} is ERC721, ERC721URIStorage, Ownable, ReentrancyGuard {{
    using Counters for Counters.Counter;

    Counters.Counter private _tokenIdCounter;
    string private _baseTokenURI;

    constructor(address initialOwner)
        ERC721("{name}", "{symbol}")
        Ownable(initialOwner)
    {{
        _baseTokenURI = "{base_uri}";
    }}

    function mint(address to, string memory uri)
        public
        onlyOwner
        nonReentrant
    {{
        require(to != address(0), "{name}: mint to zero address");

        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();

        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }}

    function _baseURI() internal view override returns (string memory) {{
        return _baseTokenURI;
    }}

    function setBaseURI(string memory newBaseURI) public onlyOwner {{
        _baseTokenURI = newBaseURI;
    }}

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {{
        return super.tokenURI(tokenId);
    }}

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {{
        super._burn(tokenId);
    }}

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (bool)
    {{
        return super.supportsInterface(interfaceId);
    }}
}}"""

            return {
                "contract_code": contract_code,
                "contract_name": name,
                "contract_type": "ERC-721",
                "features": {
                    "base_uri": base_uri,
                    "uri_storage": True,
                    "counter": True
                },
                "status": "success",
                "timestamp": datetime.now().isoformat()
            }

        except Exception as e:
            return {
                "error": f"ERC-721 generation failed: {str(e)}",
                "status": "error"
            }

    async def audit_contract_comprehensive(self, contract_data: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive contract audit using multiple analysis methods"""
        try:
            contract_code = contract_data.get("contract_code", "")
            contract_name = contract_data.get("contract_name", "Contract")

            if not contract_code.strip():
                return {
                    "error": "No contract code provided for audit",
                    "status": "error"
                }

            print(f"🔍 Starting comprehensive audit for {contract_name}")

            # Step 1: ChainGPT Security Analysis
            print("1️⃣ Running ChainGPT security analysis...")
            chaingpt_results = analyze_contract_security({
                "contract_code": contract_code,
                "contract_name": contract_name
            })

            # Step 2: Documentation Best Practices Search
            print("2️⃣ Searching for security best practices...")
            try:
                rag_query = f"smart contract security best practices for {contract_name} audit recommendations"
                rag_insights = await search_contracts_rag(rag_query)
            except Exception as e:
                rag_insights = f"RAG search failed: {str(e)}"

            # Step 3: Generate Security Recommendations
            print("3️⃣ Generating security recommendations...")
            security_recommendations = self._generate_security_recommendations(chaingpt_results, contract_code)

            # Combine all analyses
            audit_report = {
                "contract_name": contract_name,
                "timestamp": datetime.now().isoformat(),
                "chaingpt_analysis": chaingpt_results,
                "documentation_insights": rag_insights,
                "security_recommendations": security_recommendations,
                "overall_status": "completed",
                "service": "Auditooor Cloud Agent",
                "version": self.version
            }

            print("✅ Comprehensive audit completed!")
            return audit_report

        except Exception as e:
            return {
                "error": f"Comprehensive audit failed: {str(e)}",
                "status": "error"
            }

    def _generate_security_recommendations(self, chaingpt_results: Dict[str, Any], contract_code: str) -> List[str]:
        """Generate security recommendations based on audit results and code analysis"""

        recommendations = [
            "🔒 Implement proper access controls using OpenZeppelin's Ownable or AccessControl",
            "🛡️ Add reentrancy protection using ReentrancyGuard for state-changing functions",
            "⚡ Optimize gas usage while maintaining security best practices",
            "📝 Add comprehensive event emission for all critical state changes",
            "🔍 Implement input validation for all external function parameters",
        ]

        # Analyze contract code for specific recommendations
        code_lower = contract_code.lower()

        if "payable" in code_lower:
            recommendations.append("💰 Review all payable functions for proper access control and reentrancy protection")

        if "selfdestruct" in code_lower:
            recommendations.append("⚠️ Consider removing selfdestruct functionality or add strict access controls")

        if "delegatecall" in code_lower:
            recommendations.append("🚨 Audit delegatecall usage carefully - potential for storage collision attacks")

        if "_mint" in code_lower and "onlyowner" not in code_lower:
            recommendations.append("🏭 Ensure minting functions have proper access control (onlyOwner modifier)")

        if "transfer" in code_lower and "require" not in code_lower:
            recommendations.append("✅ Add require statements to validate transfer operations")

        # Add specific recommendations based on ChainGPT findings
        if isinstance(chaingpt_results, dict) and chaingpt_results.get("status") == "success":
            recommendations.append("✅ Review ChainGPT findings and implement suggested security improvements")

        return recommendations

    async def generate_contract_with_audit(self, generation_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate contract and perform immediate audit"""
        try:
            contract_type = generation_data.get("contract_type", "").lower()
            requirements = generation_data.get("requirements", {})

            # Generate the contract
            if contract_type == "erc20":
                generation_result = self.generate_erc20_template(requirements)
            elif contract_type == "erc721":
                generation_result = self.generate_erc721_template(requirements)
            else:
                return {
                    "error": f"Unsupported contract type: {contract_type}",
                    "status": "error"
                }

            if generation_result.get("status") != "success":
                return generation_result

            # Perform immediate audit
            audit_data = {
                "contract_code": generation_result["contract_code"],
                "contract_name": generation_result["contract_name"]
            }

            audit_result = await self.audit_contract_comprehensive(audit_data)

            return {
                "generation": generation_result,
                "audit": audit_result,
                "combined_status": "success",
                "timestamp": datetime.now().isoformat(),
                "service": "Auditooor Cloud Agent"
            }

        except Exception as e:
            return {
                "error": f"Contract generation with audit failed: {str(e)}",
                "status": "error"
            }

# Global instance for HTTP endpoint usage
auditooor_cloud = AuditooorCloud()