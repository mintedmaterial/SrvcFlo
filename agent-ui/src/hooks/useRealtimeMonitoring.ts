import { useState, useEffect, useCallback, useRef } from 'react';
import type {
  RealtimeEvent,
  MonitoringDashboardState,
  WebSocketConnection,
  TriggerDevTask,
  AgentPerformanceMetrics,
  ContentGenerationPipeline,
  PaymentDistribution,
  SystemHealthMetrics
} from '@/types/monitoring';

interface RealtimeMonitoringConfig {
  websocketUrl?: string;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
  enableMockData?: boolean;
}

interface UseRealtimeMonitoringReturn {
  dashboardState: MonitoringDashboardState | null;
  isConnected: boolean;
  isLoading: boolean;
  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';
  lastUpdate: Date | null;
  reconnect: () => void;
  refresh: () => void;
}

// Mock WebSocket implementation for development
class MockWebSocket {
  private callbacks: Map<string, ((data: any) => void)[]> = new Map();
  private interval: NodeJS.Timeout | null = null;
  private connected = false;

  connect(): Promise<void> {
    return new Promise((resolve) => {
      setTimeout(() => {
        this.connected = true;
        this.startMockEvents();
        resolve();
      }, 1000);
    });
  }

  disconnect(): void {
    this.connected = false;
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
  }

  get isConnected(): boolean {
    return this.connected;
  }

  subscribe(eventType: string, callback: (data: any) => void): void {
    if (!this.callbacks.has(eventType)) {
      this.callbacks.set(eventType, []);
    }
    this.callbacks.get(eventType)!.push(callback);
  }

  unsubscribe(eventType: string): void {
    this.callbacks.delete(eventType);
  }

  private startMockEvents(): void {
    this.interval = setInterval(() => {
      if (!this.connected) return;

      // Generate random events
      const eventTypes = ['workflow-update', 'agent-status', 'content-pipeline', 'payment-update', 'system-alert'];
      const randomEventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];

      const mockEvent: RealtimeEvent = {
        id: `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        type: randomEventType as any,
        timestamp: new Date(),
        data: this.generateMockEventData(randomEventType)
      };

      // Emit to subscribers
      const callbacks = this.callbacks.get(randomEventType);
      if (callbacks) {
        callbacks.forEach(callback => callback(mockEvent));
      }
    }, 3000 + Math.random() * 7000); // Random interval between 3-10 seconds
  }

  private generateMockEventData(eventType: string): any {
    const now = new Date();

    switch (eventType) {
      case 'workflow-update':
        return {
          id: 'task-content-gen',
          status: Math.random() > 0.8 ? 'completed' : 'running',
          progress: Math.floor(Math.random() * 100),
          lastRun: now
        };

      case 'agent-status':
        return {
          agentId: `agent-${Math.floor(Math.random() * 5)}`,
          status: Math.random() > 0.9 ? 'error' : 'online',
          metrics: {
            cpuUsage: Math.random() * 100,
            memoryUsage: Math.random() * 1024 * 1024 * 1024,
            averageResponseTime: 500 + Math.random() * 2000
          }
        };

      case 'content-pipeline':
        return {
          id: `content-${Date.now()}`,
          type: ['image', 'video', 'text', 'audio'][Math.floor(Math.random() * 4)],
          status: ['queued', 'processing', 'completed', 'failed'][Math.floor(Math.random() * 4)],
          progress: Math.floor(Math.random() * 100)
        };

      case 'payment-update':
        return {
          id: `payment-${Date.now()}`,
          status: ['pending', 'processing', 'completed', 'failed'][Math.floor(Math.random() * 4)],
          amount: Math.random() * 10
        };

      case 'system-alert':
        const levels = ['info', 'warning', 'error', 'critical'];
        const components = ['Database', 'Blockchain', 'Agents', 'Trigger.dev'];
        return {
          id: `alert-${Date.now()}`,
          level: levels[Math.floor(Math.random() * levels.length)],
          component: components[Math.floor(Math.random() * components.length)],
          message: 'System alert generated by mock WebSocket',
          timestamp: now,
          acknowledged: false
        };

      default:
        return {};
    }
  }
}

// Real WebSocket implementation
class RealWebSocket implements WebSocketConnection {
  private ws: WebSocket | null = null;
  private callbacks: Map<string, ((data: any) => void)[]> = new Map();
  private url: string;
  private reconnectAttempts = 0;
  private maxReconnectAttempts: number;
  private reconnectInterval: number;

  constructor(url: string, maxReconnectAttempts = 5, reconnectInterval = 5000) {
    this.url = url;
    this.maxReconnectAttempts = maxReconnectAttempts;
    this.reconnectInterval = reconnectInterval;
  }

  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.ws = new WebSocket(this.url);

        this.ws.onopen = () => {
          this.reconnectAttempts = 0;
          resolve();
        };

        this.ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            this.handleMessage(data);
          } catch (error) {
            console.error('Failed to parse WebSocket message:', error);
          }
        };

        this.ws.onclose = () => {
          this.handleDisconnect();
        };

        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          reject(error);
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  get isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }

  subscribe(eventType: string, callback: (data: any) => void): void {
    if (!this.callbacks.has(eventType)) {
      this.callbacks.set(eventType, []);
    }
    this.callbacks.get(eventType)!.push(callback);
  }

  unsubscribe(eventType: string): void {
    this.callbacks.delete(eventType);
  }

  private handleMessage(data: RealtimeEvent): void {
    const callbacks = this.callbacks.get(data.type);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }

  private handleDisconnect(): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect().catch(console.error);
      }, this.reconnectInterval);
    }
  }
}

export function useRealtimeMonitoring(config: RealtimeMonitoringConfig = {}): UseRealtimeMonitoringReturn {
  const {
    websocketUrl = process.env.NEXT_PUBLIC_TRIGGER_DEV_WS_URL || 'wss://api.trigger.dev/ws',
    reconnectInterval = 5000,
    maxReconnectAttempts = 5,
    enableMockData = false // Use real Trigger.dev connections
  } = config;

  const [dashboardState, setDashboardState] = useState<MonitoringDashboardState | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('connecting');
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);

  const wsRef = useRef<WebSocketConnection | null>(null);

  // Initialize mock data
  const generateInitialData = useCallback((): MonitoringDashboardState => {
    const now = new Date();

    return {
      workflows: [
        {
          id: 'task-content-gen',
          name: 'Content Generation Pipeline',
          type: 'content-generation',
          status: 'running',
          lastRun: new Date(now.getTime() - 300000),
          nextRun: new Date(now.getTime() + 300000),
          successRate: 0.95,
          averageDuration: 45000,
          totalRuns: 1247,
          failedRuns: 62,
          recentRuns: []
        }
      ],
      agents: [
        {
          agentId: 'agent-content',
          agentName: 'Content Agent',
          agentType: 'content',
          status: 'online',
          lastActivity: new Date(now.getTime() - 30000),
          metrics: {
            totalRequests: 15420,
            successfulRequests: 14876,
            failedRequests: 544,
            averageResponseTime: 1250,
            uptime: 0.997,
            memoryUsage: 512 * 1024 * 1024,
            cpuUsage: 23.5,
            errorRate: 0.035
          },
          healthChecks: []
        }
      ],
      contentPipeline: [],
      payments: [],
      systemHealth: {
        timestamp: now,
        overall: 'healthy',
        components: {
          database: {
            status: 'healthy',
            responseTime: 45,
            connectionPool: { active: 8, idle: 12, total: 20 }
          },
          blockchain: {
            status: 'healthy',
            network: 'sonic-mainnet',
            blockHeight: 1245678,
            gasPrice: 20,
            walletBalances: { dev: 125.45, leaderboard: 67.89, nftStaking: 234.12 }
          },
          agents: {
            status: 'healthy',
            totalAgents: 6,
            activeAgents: 5,
            errorRate: 0.025,
            averageResponseTime: 1150
          },
          triggerDev: {
            status: 'healthy',
            activeTasks: 3,
            queuedJobs: 12,
            failedJobs: 2
          },
          mcpServers: {
            status: 'healthy',
            servers: [
              { name: 'Supabase', status: 'connected', lastPing: now, responseTime: 120 },
              { name: 'Thirdweb', status: 'connected', lastPing: now, responseTime: 85 }
            ]
          }
        },
        alerts: []
      },
      isConnected: true,
      lastUpdate: now
    };
  }, []);

  // Handle real-time events
  const handleRealtimeEvent = useCallback((event: RealtimeEvent) => {
    setDashboardState(prevState => {
      if (!prevState) return prevState;

      const newState = { ...prevState };
      newState.lastUpdate = event.timestamp;

      switch (event.type) {
        case 'workflow-update':
          const workflowUpdate = event.data as Partial<TriggerDevTask>;
          const workflowIndex = newState.workflows.findIndex(w => w.id === workflowUpdate.id);
          if (workflowIndex !== -1) {
            newState.workflows[workflowIndex] = { ...newState.workflows[workflowIndex], ...workflowUpdate };
          }
          break;

        case 'agent-status':
          const agentUpdate = event.data as Partial<AgentPerformanceMetrics>;
          const agentIndex = newState.agents.findIndex(a => a.agentId === agentUpdate.agentId);
          if (agentIndex !== -1) {
            newState.agents[agentIndex] = { ...newState.agents[agentIndex], ...agentUpdate };
          }
          break;

        case 'content-pipeline':
          const contentUpdate = event.data as Partial<ContentGenerationPipeline>;
          const contentIndex = newState.contentPipeline.findIndex(c => c.id === contentUpdate.id);
          if (contentIndex !== -1) {
            newState.contentPipeline[contentIndex] = { ...newState.contentPipeline[contentIndex], ...contentUpdate };
          } else if (contentUpdate.id) {
            // Add new content item
            newState.contentPipeline.unshift(contentUpdate as ContentGenerationPipeline);
          }
          break;

        case 'payment-update':
          const paymentUpdate = event.data as Partial<PaymentDistribution>;
          const paymentIndex = newState.payments.findIndex(p => p.id === paymentUpdate.id);
          if (paymentIndex !== -1) {
            newState.payments[paymentIndex] = { ...newState.payments[paymentIndex], ...paymentUpdate };
          }
          break;

        case 'system-alert':
          const alertData = event.data as SystemHealthMetrics['alerts'][0];
          newState.systemHealth.alerts.unshift(alertData);
          // Keep only last 50 alerts
          newState.systemHealth.alerts = newState.systemHealth.alerts.slice(0, 50);
          break;

        default:
          break;
      }

      return newState;
    });

    setLastUpdate(event.timestamp);
  }, []);

  // Initialize WebSocket connection
  useEffect(() => {
    const initializeConnection = async () => {
      setIsLoading(true);
      setConnectionStatus('connecting');

      try {
        // Initialize with mock data
        const initialData = generateInitialData();
        setDashboardState(initialData);

        // Create WebSocket connection
        const ws = enableMockData ? new MockWebSocket() : new RealWebSocket(websocketUrl, maxReconnectAttempts, reconnectInterval);
        wsRef.current = ws;

        // Subscribe to events
        ws.subscribe('workflow-update', handleRealtimeEvent);
        ws.subscribe('agent-status', handleRealtimeEvent);
        ws.subscribe('content-pipeline', handleRealtimeEvent);
        ws.subscribe('payment-update', handleRealtimeEvent);
        ws.subscribe('system-alert', handleRealtimeEvent);

        // Connect
        await ws.connect();

        setIsConnected(ws.isConnected);
        setConnectionStatus('connected');
        setLastUpdate(new Date());
      } catch (error) {
        console.error('Failed to initialize WebSocket connection:', error);
        setConnectionStatus('error');
      } finally {
        setIsLoading(false);
      }
    };

    initializeConnection();

    return () => {
      if (wsRef.current) {
        wsRef.current.disconnect();
      }
    };
  }, [websocketUrl, maxReconnectAttempts, reconnectInterval, enableMockData, generateInitialData, handleRealtimeEvent]);

  // Monitor connection status
  useEffect(() => {
    const interval = setInterval(() => {
      if (wsRef.current) {
        const connected = wsRef.current.isConnected;
        setIsConnected(connected);
        setConnectionStatus(connected ? 'connected' : 'disconnected');
      }
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  const reconnect = useCallback(async () => {
    if (wsRef.current) {
      setConnectionStatus('connecting');
      try {
        await wsRef.current.connect();
        setIsConnected(wsRef.current.isConnected);
        setConnectionStatus('connected');
      } catch (error) {
        console.error('Reconnection failed:', error);
        setConnectionStatus('error');
      }
    }
  }, []);

  const refresh = useCallback(() => {
    const newData = generateInitialData();
    setDashboardState(newData);
    setLastUpdate(new Date());
  }, [generateInitialData]);

  return {
    dashboardState,
    isConnected,
    isLoading,
    connectionStatus,
    lastUpdate,
    reconnect,
    refresh
  };
}